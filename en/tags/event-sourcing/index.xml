<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Event Sourcing on Development: people, code &amp; me</title>
    <link>https://andreavallotti.tech/en/tags/event-sourcing/</link>
    <description>Recent content in Event Sourcing on Development: people, code &amp; me</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 08 Jan 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://andreavallotti.tech/en/tags/event-sourcing/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Event Sourcing and CQRS in C#</title>
      <link>https://andreavallotti.tech/en/2018/01/event-sourcing-and-cqrs-in-c/</link>
      <pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://andreavallotti.tech/en/2018/01/event-sourcing-and-cqrs-in-c/</guid>
      <description>As promised in my previous post, in this article I examine practical aspects related to DDD and, in particular to CQRS and Event Sourcing patterns.
The main goal of my experiment is to implement an aggregate according to the Event Sourcing paradigm, and to create a separate read model to feed the pages of a Web application.
Before presenting the example, I am going to briefly introduce the main architectural patterns that have been used since DDD launch.</description>
    </item>
    
  </channel>
</rss>