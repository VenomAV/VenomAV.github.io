

  
    
  


  




  


  

<!DOCTYPE html>
<html lang="en">
  <head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hugo 0.54.0">
    <meta name="theme" content="Tranquilpeak 0.3.1-BETA">
    <title>Event Sourcing and CQRS in C#</title>
    <meta name="author" content="Andrea Vallotti">
    <meta name="keywords" content="ddd, cqrs, event sourcing, architecture, development, dot-net, agile, cloud, azure, developers">

    <link rel="icon" href="https://andreavallotti.tech/images/favicon.png">
    

    
    <meta name="description" content="As promised in my previous post, in this article I examine practical aspects related to DDD and, in particular to CQRS and Event Sourcing patterns.
The main goal of my experiment is to implement an aggregate according to the Event Sourcing paradigm, and to create a separate read model to feed the pages of a Web application.
Before presenting the example, I am going to briefly introduce the main architectural patterns that have been used since DDD launch.">
    <meta property="og:description" content="As promised in my previous post, in this article I examine practical aspects related to DDD and, in particular to CQRS and Event Sourcing patterns.
The main goal of my experiment is to implement an aggregate according to the Event Sourcing paradigm, and to create a separate read model to feed the pages of a Web application.
Before presenting the example, I am going to briefly introduce the main architectural patterns that have been used since DDD launch.">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Event Sourcing and CQRS in C#">
    <meta property="og:url" content="https://andreavallotti.tech/en/2018/01/event-sourcing-and-cqrs-in-c/">
    <meta property="og:site_name" content="Development: people, code &amp; me">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:description" content="As promised in my previous post, in this article I examine practical aspects related to DDD and, in particular to CQRS and Event Sourcing patterns.
The main goal of my experiment is to implement an aggregate according to the Event Sourcing paradigm, and to create a separate read model to feed the pages of a Web application.
Before presenting the example, I am going to briefly introduce the main architectural patterns that have been used since DDD launch.">
    
      <meta name="twitter:creator" content="@AndreaVallotti">
    
    
      <meta property="fb:app_id" content="170534096895468">
    

    
    

    
      <meta property="og:image" content="https://res.cloudinary.com/andreavallotti/image/upload/blog/images/event-sourcing-cqrs/Event_Sourcing_CQRS.jpg">
    

    

    

    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" />
    
    
    <link rel="stylesheet" href="https://andreavallotti.tech/css/style-u6mk0ojoywresbx8iepslrmmhl4stuhrsxuwhkpwrkrx7mryjcaimasnk4pi.min.css" />
    
    

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-105324949-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://andreavallotti.tech/en/">Development: people, code &amp; me</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://andreavallotti.tech/#about">
    
    
    
      
        <img class="header-picture" src="https://www.gravatar.com/avatar/100b4dd001736bba121c252821f9c063?s=90" alt="Author&#39;s picture" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://andreavallotti.tech/#about">
          <img class="sidebar-profile-picture" src="https://www.gravatar.com/avatar/100b4dd001736bba121c252821f9c063?s=110" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">Andrea Vallotti</h4>
        
          <h5 class="sidebar-profile-bio">Software enthusiast: architect, developer, and technology scout. Agile addicted. MCSD - App Builder, MCSA - Cloud Platform, CSM, and CSPO. Enjoy in constantly growing while crafting <em>awesome software</em>, and helping others doing the same. <a href="https://andreavallotti.tech/en/page/about">More.</a></h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://andreavallotti.tech/en/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://andreavallotti.tech/en/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://andreavallotti.tech/en/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://andreavallotti.tech/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://andreavallotti.tech/en/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.linkedin.com/in/andrea-vallotti-b379313/" target="_blank">
    
      <i class="sidebar-button-icon fa fa-lg fa-linkedin"></i>
      
      <span class="sidebar-button-desc">LinkedIn</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://twitter.com/AndreaVallotti" target="_blank">
    
      <i class="sidebar-button-icon fa fa-lg fa-twitter"></i>
      
      <span class="sidebar-button-desc">Twitter</span>
    </a>
  </li>

    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://andreavallotti.tech/en/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://andreavallotti.tech/it/">
    
      <i class="sidebar-button-icon fa fa-lg fa-language"></i>
      
      <span class="sidebar-button-desc">Italiano</span>
    </a>
  </li>

    </ul>
  </div>
</nav>

      
  <div class="post-header-cover
              text-left
              post-header-cover--partial"
       style="background-image:url('https://res.cloudinary.com/andreavallotti/image/upload/blog/images/event-sourcing-cqrs/Event_Sourcing_CQRS.jpg')"
       data-behavior="4">
    
      <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      Event Sourcing and CQRS in C#
    </h1>
  
  <div class="postShorten-meta post-meta">
  
    <time itemprop="datePublished" datetime="2018-01-08T00:00:00Z">
      
  
  
  
  
    8 January 2018
  

    </time>
  
  
  
  
    <span>in</span>
    
      <a class="category-link" href="https://andreavallotti.tech/en/categories/development">Development</a>
    
  


</div>

</div>
    
  </div>


      <div id="main" data-behavior="4"
        class="hasCover
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              

<p>As promised in my <a href="https://andreavallotti.tech/en/2017/11/strategic-domain-driven-design/">previous post</a>,
in this article I examine practical aspects related to DDD and, in particular to
<a href="https://martinfowler.com/bliki/CQRS.html">CQRS</a> and <a href="https://martinfowler.com/eaaDev/EventSourcing.html">Event Sourcing</a>
patterns.</p>

<p>The main goal of my experiment is to implement an aggregate according to the Event
Sourcing paradigm, and to create a separate read model to feed the pages of a Web
application.</p>

<p>Before presenting the example, I am going to briefly introduce the main architectural
patterns that have been used since DDD launch.</p>

<p>Getting familiar with the use of CQRS and Event Sourcing was not easy. However, I
was able to succeed thanks to the foundational skills built through <a href="https://www.avanscoperta.it/en/training/domain-driven-design-modelling-workshop/">Avanscoperta&rsquo;s training</a>,
a massive dose of readings (<a href="https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577">Vaugh Vernon&rsquo;s red book</a>
and several posts), and an adequate number of attempts always supported by tests.</p>

<p>The full source code I’m going to mention with examples in the post, is available
on <a href="https://github.com/VenomAV/EventSourcingCQRS">GitHub</a>.</p>

<p>The journey continues. In the meantime, I treasure the learnings, and I enjoy the
view of the horizon.</p>

<h2 id="architectures-evolution">Architectures evolution</h2>

<p><a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">Evans&rsquo; blue book</a>
was published in 2003 and since then different architectural styles have emerged.
During this evolution, DDD guidelines have always remained valid, except for some
technicalities necessary for the implementation of the various architectures.</p>

<h3 id="layered-architecture">Layered architecture</h3>

<p>Layered architecture is the original architecture used by Evans to isolate the domain
logic from the other responsibilities of an application. The standard layers in which
to split an application are:</p>

<ul>
<li><strong>UI</strong>, is the layer responsible for displaying information to the users and interpreting
their commands;</li>
<li><strong>Application</strong>, defines the possible scenarios of the application use cases.
It coordinates the domain objects and takes care of managing all the activities
necessary for the correct functioning of the application. For example, security,
transactions, etc.;</li>
<li><strong>Domain</strong>, contains everything related to the domain logic. The state of the
domain objects is managed by this layer even if the persistence of the objects
themselves is delegated to the infrastructure. This is the layer where the DDD
guidelines are applied;</li>
<li><strong>Infrastructure</strong>, does not contain neither domain logic nor application logic,
but provides the technical implementations that serve the other layers to work.
For example, persistence, transaction management, etc.</li>
</ul>

<p>The fundamental rule of this architecture is that each layer can depend only on those
below. The only way for the underlying layers to communicate with the upper layers
is through the use of <a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer</a>
and <a href="https://en.wikipedia.org/wiki/Mediator_pattern">Mediator</a> patterns.</p>

<p>The clear separation of the domain model in a layer distinct from the others allows
you to develop and test business rules in total autonomy compared to the rest of
the application.</p>

<p>The only cons of this approach is given by the dependence of the domain layer on
the infrastructure layer, even if this could be well mitigated by the use of clear
and well-defined interfaces.</p>

<h3 id="hexagonal-architecture">Hexagonal architecture</h3>

<p>The <a href="http://alistair.cockburn.us/Hexagonal+architecture">Hexagonal architecture</a>
by Alistair Cockburn, solves the problems of the previous architecture and introduces
a more symmetrical application model. Basically in this architecture there is no
longer a top and a bottom, but only the concepts of inside and the outside.</p>

<p>The <em>inside</em> consists of what used to be the application layer and the domain layer,
simply defined as &ldquo;application&rdquo; by Cockburn. In other words, all that implements
the use cases of business’s interest. The inside communicates with the outside through
&ldquo;ports&rdquo; defined by the application itself. Examples of ports can be the public application
API, the data access interface, and the domain event publishing interface.</p>

<p>The <em>outside</em> consists of everything that interacts with the application or, vice
versa, with which the latter interacts. The interaction always occurs through adapters
which either adapt the external signals to the application’s API, or implement the
interfaces necessary for the correct operation of the latter. Examples of adapters
could be the controllers that interpret HTTP requests and invoke application APIs
or SQL implementation of data access interfaces.</p>

<p>Using DDD, Cockburn&rsquo;s <em>inside</em> is commonly divided into two concentric levels:</p>

<ul>
<li>the internal, consisting of the domain model that implements the business rules;</li>
<li>and the external one consists of the application services which define the usage
scenarios.</li>
</ul>

<p>This architecture allows to develop the application in total autonomy with respect
to the external conditions (UI, database, etc.), allowing to execute it, and test
it, in various configurations: with UI, from command line, etc.</p>

<p>The Hexagonal architecture is widely adopted and is the foundation of all the architectures
that came after, including the patterns described below.</p>

<h3 id="cqrs">CQRS</h3>

<p>In the traditional approaches, some described above, a single data model is used
together with the related services, for writing and reading operations. This often
leads to the creation of suboptimal models that often expose lots of information.
Furthermore, this can lead to an excessive coupling between the model and the client
code that uses it.</p>

<p><a href="https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf">Command Query Responsibility Segregation</a>
(CQRS) is an architectural pattern which separates the responsibility for modifying
data (Command) from reading them (Query). The formalization of this approach is generally
attributed to <a href="https://twitter.com/gregyoung">Greg Young</a>.</p>

<p>The use of two different models for writing and reading operations, in scope of CQRS,
allows instead to design and optimize each model for its responsibilities. In addition
to this, the use of distinct models also allows the selection of the most appropriate
technologies. For example, we could decide to use different persistence mechanisms:
for reading could be more appropriate to use a relational DB, while in writing we
would prefer a NoSQL.</p>

<p>As soon as the reading and writing models are separated, the infrastructure could
easily scale to best fit the needs. It often happens that the number of writings
in a system is much lower than the readings. Therefore, using separate models and
technologies will let scale differently the infrastructure related to the reading,
in respect to the writing one.</p>

<p>Obviously the two models must be synchronized to ensure that the read information
are consistent with the written ones. The consistency could not be immediate but
must be eventually achieved. In DDD, synchronization occurs through the <a href="http://domainlanguage.com/wp-content/uploads/2016/05/DDD_Reference_2015-03.pdf">Domain Event</a>
generated by the aggregates.</p>

<p>The use of Domain Events to synchronize the reading model with the writing model
has only one cons: generally the event emission and persistence are not transactional.
This is due to the fact that the message management system and the persistence system
are separate systems (e.g. RabbitMQ and SQL Server).</p>

<h3 id="event-sourcing">Event sourcing</h3>

<p><a href="https://martinfowler.com/eaaDev/EventSourcing.html">Event sourcing</a> (ES) overcomes
the problem described above in an extremely elegant way. Let&rsquo;s see how.</p>

<p>Normally to persist an aggregate at a given moment, its state is saved to a database.
Using ES instead, what is saved is not the current state of the aggregate but the
sequence of Domain Events that led the aggregate into its current state. To load
an aggregate it is sufficient to read all the events associated with it and to replay
them.</p>

<p>In this way, every time an aggregate is modified, a new record is appended to the
flow of the events that represent it instead of updating an existing record. This
approach is very efficient because it eliminates the risk of concurrent locking on
table records and, consequently, the possibility of deadlocks between different writing
threads.</p>

<p>This type of persistence is called <em>event store</em>. You can create your own event store
as described in <a href="https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577">Vaughn Vernon&rsquo;s book</a>,
using a relational database, or, as we&rsquo;ll see later, you can use an existing product
that provides this specific functionality.</p>

<p>Back to the problem of non-transactionality mentioned above, using an event store
you have a single place where the Domain Events and, implicitly, the status of the
aggregates are saved. It is therefore sufficient to read the unpublished events from
the event store to avoid risks of inconsistency between the writing and reading models.</p>

<h2 id="the-application">The application</h2>

<p>Let&rsquo;s have hands on. To deep dive on the architectural patterns briefly described
above, and experiment them practically, I decided to develop a test application with
the aim of implementing an aggregate according to the Event Sourcing paradigm, and
to create a separate reading model that could be used to feed the pages of the Web
application.</p>

<p>Moreover, I wanted to use <a href="https://eventstore.org/">Event Store</a> in order to persist
events. As the name suggests, Event Store is an event store developed, among the
others, by Greg Young.</p>

<p>The application allows you to create carts and add products by specifying the quantity.
The use cases are very simple:</p>

<ul>
<li>it is be possible to create a cart by supplying the customer to whom it belongs;</li>
<li>it is be possible to add a product to the cart specifying the quantity, provided
that the product is not already in the cart;</li>
<li>it is possible to change the quantity of a product already in a cart;</li>
<li>finally, for each product it should not be possible to add more than 50 units.</li>
</ul>

<p>I developed the application using ASP.NET Core, C# and Docker.</p>

<h2 id="model-an-aggregate-following-event-sourcing">Model an aggregate following Event Sourcing</h2>

<p>To deal with the problem described above, I started from modeling the <code>Cart</code> aggregate.
Following a classic approach, I started thinking about the classes’ properties
that I would have to persist on the database using Entity Framework but, after an
initial indecision, I changed the approach.</p>

<p>I started thinking about the domain events that the aggregate should have generated
for the use cases described above, and I started with the creation of a new cart.</p>


  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>Extract from CartTest.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">[Fact]
public void GivenNoCartExistsWhenCreateOneThenCartCreatedEvent()
{
    var cart = new Cart(DefaultCartId, DefaultCustomerId);

    AssertSingleUncommittedEvent&lt;CartCreatedEvent&gt;(cart, @event =&gt;
    {
      Assert.Equal(DefaultCartId, @event.AggregateId);
      Assert.Equal(DefaultCustomerId, @event.CustomerId);
    });
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<p>As can be seen from the test, when I create a new cart instance, providing its own
identifier and the identifier of its customer, I expect only one event of type <code>CartCreatedEvent</code>
to be published, and that the latter contains the correct information. The <code>AssertSingleUncommittedEvent</code>
method is a utility method of the test class to check the event generated by the
aggregate and not yet committed.</p>

<p>Following the Event Sourcing paradigm, every action performed on an aggregate, even
its creation, is divided into three conceptual steps:</p>

<ol>
<li>verification of the input parameters and the status of the aggregate in order
to check feasibility of the action;</li>
<li>if the previous checks are positive, publishing of the events triggered by the
action;</li>
<li>updating of the aggregate&rsquo;s state according to the events mentioned above.</li>
</ol>

<p>Keeping steps 2 and 3 separated, as explained later, is necessary when we need to
recreate an object starting from the events present on the event store. With these
guidelines, to meet the above test, I created the following class.</p>


  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>Extract from Cart.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">public class Cart : AggregateBase&lt;CartId&gt;
{
    private CustomerId CustomerId { get; set; }

    public Cart(CartId cartId, CustomerId customerId) : this()
    {
        if (cartId == null) throw new ArgumentNullException(nameof(cartId));
        if (customerId == null) throw new ArgumentNullException(nameof(customerId));
        RaiseEvent(new CartCreatedEvent(cartId, customerId));
    }

    internal void Apply(CartCreatedEvent ev)
    {
        Id = ev.AggregateId;
        CustomerId = ev.CustomerId;
    }
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<p>The code reflects the three steps described above: verification (lines 7 and 8),
events publishing (line 9), and status update (<code>Apply</code> method).</p>

<p>In order to make the reading of the <code>Cart</code> class easier and to avoid duplications,
I created the <code>AggregateBase</code> base class that basically acts as a <a href="https://martinfowler.com/eaaCatalog/layerSupertype.html">Layer Supertype</a>
for the domain aggregates. The base class is described in more detail later.</p>

<p>Likewise to what was done for the creation of a new cart, to implement the use case
of adding a product to the cart, I started from the definition of the test.

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>Extract from CartTest.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">[Fact]
public void GivenACartWhenAddAProductThenProductAddedEvent()
{
    var cart = new Cart(DefaultCartId, DefaultCustomerId);
    ClearUncommittedEvents(cart);

    cart.AddProduct(DefaultProductId, 2);

    AssertSingleUncommittedEvent&lt;ProductAddedEvent&gt;(cart, @event =&gt;
    {
        Assert.Equal(DefaultProductId, @event.ProductId);
        Assert.Equal(2, @event.Quantity);
        Assert.Equal(DefaultCartId, @event.AggregateId);
        Assert.Equal(0, @event.AggregateVersion);
    });
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
The only difference from the previous test is the use of the <code>ClearUncommittedEvents</code>
utility method to clear the list of the uncommitted events. Apart from this detail,
also in this case the test is easily readable: when I add a product to the cart
I expect the corresponding event to be published and to contain the data describing
the operation just happened.</p>

<p>It is important to note that I did not make any statement about the status (properties
or fields) of the <code>Cart</code> class. In fact, I do not care how the class internally manages
its status, but simply want to make sure that the correct events are issued. In fact,
these allow me to build a reading model for my web application.</p>

<p>This is the perfect application of the &ldquo;encapsulation&rdquo; principle. I will never be
able to thank <a href="https://twitter.com/ziobrando">Ziobrando</a> enough for having found
the perfect metaphor for such a simple and often underestimated concept that could
be appreciated only by those who speak Italian: <a href="https://www.youtube.com/watch?v=7Lb5ZErTMZU">Black Knight</a>.
This is a good reason to take some Italian classes!</p>

<p>The status of the aggregate is fundamental for its correct functioning. To make sure
that the aggregate manage the status correctly, it was sufficient to add the following
test.

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>Extract from CartTest.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">[Fact]
public void GivenACartWithAProductWhenAddingTheSameProductThenThrowsCartException()
{
    var cart = new Cart(DefaultCartId, DefaultCustomerId);

    cart.AddProduct(DefaultProductId, 2);
    ClearUncommittedEvents(cart);

    Assert.Throws&lt;CartException&gt;(() =&gt; { cart.AddProduct(DefaultProductId, 1); });
    Assert.Empty(GetUncommittedEventsOf(cart));
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
If <code>Cart</code> did not correctly manage its status, it would not be able to check whether
it already contains the product or not.</p>

<p>Given the tests above, the implementation of the expected behavior was the following.

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>Extract from Cart.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">public class Cart : AggregateBase&lt;CartId&gt;
{
  private List&lt;CartItem&gt; Items { get; set; }

  public void AddProduct(ProductId productId, int quantity)
  {
    if (productId == null)
    {
      throw new ArgumentNullException(nameof(productId));
    }
    if (ContainsProduct(productId))
    {
      throw new CartException($&#34;Product {productId} already added&#34;);
    }
    RaiseEvent(new ProductAddedEvent(productId, quantity));
  }

  internal void Apply(ProductAddedEvent ev)
  {
    Items.Add(new CartItem(ev.ProductId, ev.Quantity));
  }

  private bool ContainsProduct(ProductId productId)
  {
    return Items.Any(x =&gt; x.ProductId == productId);
  }
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>Extract from CartItem.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">public class CartItem
{
  public CartItem(ProductId productId, int quantity)
  {
    ProductId = productId;
    Quantity = quantity;
  }

  public ProductId ProductId { get; }

  public int Quantity { get; }
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
Note that the cart maintains a list of added items, but the list is not accessible
outside the class. The list is only useful for the implementation of expected behaviors
and must not be used in any way by the client code. I would like to highlight that
for the implementation of last use case, it would not have been necessary to keep
the quantities in the list. It would have been enough to maintain a list of product
identifiers. The quantity is there just because it is useful to implement the other
use cases described above.</p>

<p>Since the article is already quite full of concepts, I will avoid describing the
implementation of the other use cases. I leave it to those interested in consulting
the code on <a href="https://github.com/VenomAV/EventSourcingCQRS">GitHub</a>.</p>

<h3 id="aggregatebase">AggregateBase</h3>

<p><code>AggregateBase</code> implements two basic interfaces. The first is <code>IAggregate</code> which
states that each aggregate must have an identifier.

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>IAggregate.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">public interface IAggregate&lt;TId&gt;
{
    TId Id { get; }
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure></p>

<p>The second interface defines the signatures of the methods needed to work with the
Event Sourcing paradigm. Each aggregate must have a version (<code>Version</code>) in order
to manage potential writing conflicts. It must also be possible to apply domain events
(<code>ApplyEvent</code>), this is useful for load an aggregate from the event store. Finally,
obtaining the uncommitted events (<code>GetUncommittedEvents</code>), and clear it (<code>ClearUncommittedEvents</code>)
must be possible.

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>IEventSourcingAggregate.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">internal interface IEventSourcingAggregate&lt;TAggregateId&gt;
{
    long Version { get; }
    void ApplyEvent(IDomainEvent&lt;TAggregateId&gt; @event, long version);
    IEnumerable&lt;IDomainEvent&lt;TAggregateId&gt;&gt; GetUncommittedEvents();
    void ClearUncommittedEvents();
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
The interface is declared <code>internal</code> because it is visible only inside the assembly
which contains the domain objects. This is an implementation detail that does not
matter to client code.</p>

<p>The <code>AggregateBase</code> class implements the above interfaces pretty smoothly. There
are two methods that deserve further examination: <code>ApplyEvent</code> and <code>RaiseEvent</code>.</p>

<p><strong>ApplyEvent</strong> - in order avoid duplication, the <code>ApplyEvent</code> method verifies that
the event to be applied is not among those uncommitted. In case the event is actually
to be applied, line 18 allows to invoke the specific method to apply the domain event.</p>

<p>In the case of the <code>Car</code>t class and <code>CartCreatedEvent</code> event, using the <code>dynamic</code>
keyword allows the <code>AggregateBase</code> class to dynamically invoke the
<code>internal void Apply(CartCreatedEvent ev)</code> method of the <code>Cart</code> class at runtime.</p>

<p><a href="https://gist.github.com/heemskerkerik/0a850919f6467431963f667ae260092f">This benchmark</a>
shows that the dynamic invocation of methods, although slower than <code>switch</code> with
pattern matching, is still much faster than other options.</p>

<p><strong>RaiseEvent</strong> - this method guarantees to assign the aggregate&rsquo;s correct version
and the identifier to the publishing event, simplifying the code of the <code>Cart</code> class.
Moreover, before appending the event to the uncommitted ones, it applies the event
itself to the aggregate so that the state of the latter is consistent with the published
events.</p>


  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>AggregateBase.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">public abstract class AggregateBase&lt;TId&gt; : 
  IAggregate&lt;TId&gt;, IEventSourcingAggregate&lt;TId&gt;
{
  public const long NewAggregateVersion = -1;

  private readonly ICollection&lt;IDomainEvent&lt;TId&gt;&gt; _uncommittedEvents = 
    new LinkedList&lt;IDomainEvent&lt;TId&gt;&gt;();
  private long _version = NewAggregateVersion;

  public TId Id { get; protected set;  }

  long IEventSourcingAggregate&lt;TId&gt;.Version =&gt; _version;

  void IEventSourcingAggregate&lt;TId&gt;.ApplyEvent(IDomainEvent&lt;TId&gt; @event, long version)
  {
    if (!_uncommittedEvents.Any(x =&gt; Equals(x.EventId, @event.EventId)))
    {
      ((dynamic)this).Apply((dynamic)@event);
      _version = version;
    }
  }

  void IEventSourcingAggregate&lt;TId&gt;.ClearUncommittedEvents()
    =&gt; _uncommittedEvents.Clear();

  IEnumerable&lt;IDomainEvent&lt;TId&gt;&gt; IEventSourcingAggregate&lt;TId&gt;.GetUncommittedEvents()
    =&gt; _uncommittedEvents.AsEnumerable();

  protected void RaiseEvent&lt;TEvent&gt;(TEvent @event)
      where TEvent: DomainEventBase&lt;TId&gt;
  {
    IDomainEvent&lt;TId&gt; eventWithAggregate = @event.WithAggregate(
      Equals(Id, default(TId)) ? @event.AggregateId : Id,
      _version);

    ((IEventSourcingAggregate&lt;TId&gt;)this).ApplyEvent(eventWithAggregate, _version &#43; 1);
    _uncommittedEvents.Add(@event);
  }
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

<h3 id="persistence">Persistence</h3>

<p>Following a classic DDD approach, to access the aggregates and to persist them, I
would define an <code>IRepository</code> interface in the domain model with these classic operations:
<code>GetByID</code>, <code>Remove</code>, and <code>Save</code>, plus any specialized search methods. After that
I would implement this interface in some supporting assembly. This implementation
would be dependent on some persistence mechanism and this dependence would certainly
be made explicit by the name of the implementation itself, e.g. <code>EntityFrameworkRepository</code>.</p>

<p>Using Event Sourcing the interface definition, and its implementation, take a different
shape. First of all, the <code>IRepository</code> interface is simpler.

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>IRepository.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">public interface IRepository&lt;TAggregate, TAggregateId&gt;
  where TAggregate: IAggregate&lt;TAggregateId&gt;
{
  Task&lt;TAggregate&gt; GetByIdAsync(TAggregateId id);

  Task SaveAsync(TAggregate aggregate);
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
Searching on an event store by attribute is complex and definitely not well performing.
In addition, event stores are append-only persistence mechanisms, therefore previously
written events can not be deleted. For these reasons the only suitable operations
are the recovery of an aggregate through its identifier, and the saving of an aggregate,
whether new or pre-existing.</p>

<p>Concerning the implementation, the repository must be aware at least about the methods
of the <code>IEventSourcingAggregate</code> interface in order to access the domain uncommitted
events of an aggregate, and to apply the events retrieved from the event store to
an aggregate. For this reason it is more natural to put part of the repository implementation
in the same assembly that contains the domain model.

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>EventSourcingRepository.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">public class EventSourcingRepository&lt;TAggregate, TAggregateId&gt; :
    IRepository&lt;TAggregate, TAggregateId&gt;
  where TAggregate : AggregateBase&lt;TAggregateId&gt;, IAggregate&lt;TAggregateId&gt;
  where TAggregateId : IAggregateId
{
  private readonly IEventStore eventStore;
  private readonly ITransientDomainEventPublisher publisher;

  public EventSourcingRepository(IEventStore eventStore,
    ITransientDomainEventPublisher publisher)
  {
    this.eventStore = eventStore;
    this.publisher = publisher;
  }

  public async Task&lt;TAggregate&gt; GetByIdAsync(TAggregateId id)
  {
    try
    {
      var aggregate = CreateEmptyAggregate();
      IEventSourcingAggregate&lt;TAggregateId&gt; aggregatePersistence = aggregate;

      foreach (var @event in await eventStore.ReadEventsAsync(id))
      {
        aggregatePersistence.ApplyEvent(@event.DomainEvent, @event.EventNumber);
      }
      return aggregate;
    }
    catch (EventStoreAggregateNotFoundException)
    {
      return null;
    }
    catch (EventStoreCommunicationException ex)
    {
      throw new RepositoryException(&#34;Unable to access persistence layer&#34;, ex);
    }
  }

  public async Task SaveAsync(TAggregate aggregate)
  {
    try
    {
      IEventSourcingAggregate&lt;TAggregateId&gt; aggregatePersistence = aggregate;

      foreach (var @event in aggregatePersistence.GetUncommittedEvents())
      {
        await eventStore.AppendEventAsync(@event);
        await publisher.PublishAsync((dynamic)@event);
      }
      aggregatePersistence.ClearUncommittedEvents();
    }
    catch (EventStoreCommunicationException ex)
    {
      throw new RepositoryException(&#34;Unable to access persistence layer&#34;, ex);
    }
  }

  private TAggregate CreateEmptyAggregate()
  {
    return (TAggregate)typeof(TAggregate)
      .GetConstructor(
        BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public, 
        null, new Type[0], new ParameterModifier[0])
      .Invoke(new object[0]);
  }
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure></p>

<p>The repository implementation piece that remains outside the domain model is the
one related to the specific used event store. For this purpose I introduced the <code>IEventStore</code>
interface. The implementation of this interface is explained later.

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>IEventStore.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">public interface IEventStore
{
  Task&lt;IEnumerable&lt;Event&lt;TAggregateId&gt;&gt;&gt; ReadEventsAsync&lt;TAggregateId&gt;(TAggregateId id)
    where TAggregateId: IAggregateId;

  Task&lt;AppendResult&gt; AppendEventAsync&lt;TAggregateId&gt;(IDomainEvent&lt;TAggregateId&gt; @event)
    where TAggregateId: IAggregateId;
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure></p>

<p>Back to the <code>EventSourcingRepository</code> class, you can see how the <code>GetByIdAsync</code> method
applies all events retrieved from the event store to an empty instance of the aggregate
using the <code>ApplyEvent</code> method. The empty aggregate instance is created using the
<code>CreateEmptyAggregate</code> method. This method makes use of C# reflection to create an
aggregate using its default constructor. I decided to use reflection because I want
the aggregates to be able to declare the default constructor as private, as in the
case of the <code>Cart</code> class. This is because exposing the default constructor or not
must be an aggregate design choice, not an architectural constraint.</p>

<p>Regarding <code>SaveAsync</code> method, it deals with recovering the uncommitted events from
the aggregate, save them on the event store and, if all work well, remove them from
the aggregate.</p>

<p>I also decided to use this method to publish events internally to the application
through the <code>ITransientDomainEventPublisher</code> interface. The class that implements
this interface is nothing more than a <em>lightweight publisher</em> as described in chapter
8 (Domain Events) of <a href="https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577">Vaugh Vernon&rsquo;s red book</a>.
Unlike the book, in my case the events are published by the repository instead of
the aggregates. For two reasons: the aggregate code is simpler, and the <code>SaveAsync</code>
method is the only one in which we are sure that the events have been saved and there
are no conflicts.</p>

<h2 id="event-store">Event Store</h2>

<p>For this experiment I used <a href="https://eventstore.org/">Event Store</a> to persist the
Event Sourcing model. In order to setup the environment I included <code>eventstore/eventstore</code>
Docker image in the <code>docker-compose.yml</code> file of my project. I used the basic settings
since I did not have specific needs.</p>

<p>In order to communicate with the Event Store server, I installed the NuGet package
<code>EventStore.ClientAPI.NetCore</code>, version 4.0.3-rc. Since I haven&rsquo;t ever used this
product I created some tests to check the behavior of the library and the server.
After that, I implemented the <code>IEventStore</code> interface described above.</p>

<p>Event Store provides several interesting features like projection. In order to use
them, Event Store requires that the event are persisted in JSON format. Since other
event store could rely on other encodings, I decided to implement serialization and
deserialization of events at this level.</p>

<p>For the sake of conciseness, I did not place the implementation here. It could be
found on <a href="https://github.com/VenomAV/EventSourcingCQRS/tree/master/EventSourcingCQRS.Domain.EventStore/EventStoreEventStore.cs">GitHub</a>.</p>

<h2 id="cqrs-and-read-model">CQRS and read model</h2>

<p>As already mentioned above, using Event Sourcing for the domain model, we miss a
read model to show information to the user. CQRS comes to the rescue.</p>

<p>Following the guidelines of this pattern, I created a simple read model which satisfy
the Web application needs.

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>EventSourcingCQRS.ReadModel\Cart\Cart.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">public class Cart : IReadEntity
{
  public string Id { get; set; }
  public int TotalItems { get; set; }
  public string CustomerId { get; set; }
  public string CustomerName { get; set; }
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>EventSourcingCQRS.ReadModel\Cart\CartItem.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">public class CartItem : IReadEntity
{
    public string Id { get; private set; }
    public string CartId { get; set; }
    public string ProductId { get; set; }
    public string ProductName { get; set; }
    public int Quantity { get; set; }

    public static CartItem CreateFor(string cartId, string productId)
    {
      return new CartItem
      {
        Id = IdFor(cartId, productId),
        CartId = cartId,
        ProductId = productId
      };
    }

    public static string IdFor(string cartId, string productId)
    {
      return $&#34;{productId}@{cartId}&#34;;
    }
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure></p>

<p>This model have to be synchronized with the write model. For this reason I created
the <code>CartUpdater</code> class which, handling the domain events published by the write
model, is in charge of updating the read model.

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>CartUpdater.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">public class CartUpdater : IDomainEventHandler&lt;CartId, CartCreatedEvent&gt;,
  IDomainEventHandler&lt;CartId, ProductAddedEvent&gt;,
  IDomainEventHandler&lt;CartId, ProductQuantityChangedEvent&gt;
{
  private readonly IReadOnlyRepository&lt;Customer.Customer&gt; customerRepository;
  private readonly IReadOnlyRepository&lt;Product.Product&gt; productRepository;
  private readonly IRepository&lt;Cart.Cart&gt; cartRepository;
  private readonly IRepository&lt;Cart.CartItem&gt; cartItemRepository;

  public CartUpdater(IReadOnlyRepository&lt;Customer.Customer&gt; customerRepository,
    IReadOnlyRepository&lt;Product.Product&gt; productRepository,
    IRepository&lt;Cart.Cart&gt; cartRepository,
    IRepository&lt;Cart.CartItem&gt; cartItemRepository)
  {
    this.customerRepository = customerRepository;
    this.productRepository = productRepository;
    this.cartRepository = cartRepository;
    this.cartItemRepository = cartItemRepository;
  }

  public async Task HandleAsync(CartCreatedEvent @event)
  {
    var customer = await customerRepository.GetByIdAsync(
      @event.CustomerId.IdAsString());

    await cartRepository.InsertAsync(new Cart.Cart
      {
        Id = @event.AggregateId.IdAsString(),
        CustomerId = customer.Id,
        CustomerName = customer.Name,
        TotalItems = 0
      });
  }

  public async Task HandleAsync(ProductAddedEvent @event)
  {
    var product = await productRepository.GetByIdAsync(@event.ProductId.IdAsString());
    var cart = await cartRepository.GetByIdAsync(@event.AggregateId.IdAsString());
    var cartItem = Cart.CartItem.CreateFor(
      @event.AggregateId.IdAsString(),
      @event.ProductId.IdAsString());

    cartItem.ProductName = product.Name;
    cartItem.Quantity = @event.Quantity;
    cart.TotalItems &#43;= @event.Quantity;
    await cartRepository.UpdateAsync(cart);
    await cartItemRepository.InsertAsync(cartItem);
  }

  public async Task HandleAsync(ProductQuantityChangedEvent @event)
  {
    var cartItemId = Cart.CartItem.IdFor(
      @event.AggregateId.IdAsString(),
      @event.ProductId.IdAsString());
    var cartItem = (await cartItemRepository
      .FindAllAsync(x =&gt; x.Id == cartItemId))
      .Single();
    var cart = await cartRepository.GetByIdAsync(@event.AggregateId.IdAsString());

    cart.TotalItems &#43;= @event.NewQuantity - @event.OldQuantity;
    cartItem.Quantity = @event.NewQuantity;

    await cartRepository.UpdateAsync(cart);
    await cartItemRepository.UpdateAsync(cartItem);
  }
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
<code>IRepository</code> and <code>IReadOnlyRepositoy</code> interfaces differ from the <code>IRepository</code> interface
described in <em>Repository</em> paragraph. These interfaces belong to the <code>EventSourcingCQRS.ReadModel</code>
project and they are used to access the read model. The only interaction between
<code>CartUpdater</code> class and the write model is through the domain events published by
the latter.</p>

<p>Incidentally, the implementation of <code>IRepository</code> and <code>IReadOnlyRepositoy</code> uses <a href="https://www.mongodb.com/">MongoDB</a>
and it does not have access to the Event Store.</p>

<p>An issue that often arise when using CQRS is the delay between the actions on the
write model and the update of the read model. Since this is just an example, I decide
to solve this problem in a fast way: I registered <code>CartUpdater</code> class as consumer
of the lightweight publisher described above. In this way I can guarantee that the
read model is updated even before the <code>SaveAsync</code> method (see <em>Repository</em> paragraph)
is completed.</p>

<p>This is not the right approach to solve the delay issue since it decrease the scalability
of the system since it bounds the operations on the domain model to the update of
the read model. Nonetheless, if you are working on an existing application and you
are introducing these patterns, this could be a feasible way to do it gradually.</p>

<p>Back to the code, who is in charge of coordinating the action on the write model
and the update of the read model is an application service called <code>CartWriter</code>. See
it below.

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>CartWriter.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">public class CartWriter : ICartWriter
{
  private readonly IRepository&lt;Cart, CartId&gt; cartRepository;
  private readonly ITransientDomainEventSubscriber subscriber;
  private readonly IEnumerable&lt;IDomainEventHandler&lt;CartId, CartCreatedEvent&gt;&gt; cartCreatedEventHandlers;
  private readonly IEnumerable&lt;IDomainEventHandler&lt;CartId, ProductAddedEvent&gt;&gt; productAddedEventHandlers;
  private readonly IEnumerable&lt;IDomainEventHandler&lt;CartId, ProductQuantityChangedEvent&gt;&gt; productQuantityChangedEventHandlers;

  public CartWriter(IRepository&lt;Cart, CartId&gt; cartRepository, ITransientDomainEventSubscriber subscriber,
      IEnumerable&lt;IDomainEventHandler&lt;CartId, CartCreatedEvent&gt;&gt; cartCreatedEventHandlers,
      IEnumerable&lt;IDomainEventHandler&lt;CartId, ProductAddedEvent&gt;&gt; productAddedEventHandlers,
      IEnumerable&lt;IDomainEventHandler&lt;CartId, ProductQuantityChangedEvent&gt;&gt; productQuantityChangedEventHandlers)
  {
    this.cartRepository = cartRepository;
    this.subscriber = subscriber;
    this.cartCreatedEventHandlers = cartCreatedEventHandlers;
    this.productAddedEventHandlers = productAddedEventHandlers;
    this.productQuantityChangedEventHandlers = productQuantityChangedEventHandlers;
  }

  public async Task AddProductAsync(string cartId, string productId, int quantity)
  {
    var cart = await cartRepository.GetByIdAsync(new CartId(cartId));

    subscriber.Subscribe&lt;ProductAddedEvent&gt;(
      async @event =&gt; await HandleAsync(productAddedEventHandlers, @event));
    cart.AddProduct(new ProductId(productId), quantity);
    await cartRepository.SaveAsync(cart);
  }

  public async Task ChangeProductQuantityAsync(
      string cartId, string productId, int quantity)
  {
    var cart = await cartRepository.GetByIdAsync(new CartId(cartId));

    subscriber.Subscribe&lt;ProductQuantityChangedEvent&gt;(
      async @event =&gt; await HandleAsync(productQuantityChangedEventHandlers, @event));
    cart.ChangeProductQuantity(new ProductId(productId), quantity);
    await cartRepository.SaveAsync(cart);
  }

  public async Task CreateAsync(string customerId)
  {
    var cart = new Cart(CartId.NewCartId(), new CustomerId(customerId));

    subscriber.Subscribe&lt;CartCreatedEvent&gt;(
      async @event =&gt; await HandleAsync(cartCreatedEventHandlers, @event));
    await cartRepository.SaveAsync(cart);
  }

  public async Task HandleAsync&lt;T&gt;(
      IEnumerable&lt;IDomainEventHandler&lt;CartId, T&gt;&gt; handlers, T @event)
    where T : IDomainEvent&lt;CartId&gt;
  {
    foreach (var handler in handlers)
    {
      await handler.HandleAsync(@event);
    }
  }
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
As you can see from the code, the <code>CartWriter</code> service did not know anything about
<code>CartUpdater</code> class. The latter is just injected ad implementation of <code>IDomainEventHandler</code>
interface. <code>CartWriter</code> just subscribes all the injected handlers.</p>

<p>The <code>ITransientDomainEventSubscriber</code> interface is the counterpart of <code>ITransientDomainEventPublisher</code>
interface seen above. Both the interfaces are implemented by the <code>TransientDomainEventPubSub</code>
class, which is charge of dispatching all the published events to the corresponding
subscribers. I called this class <em>transient</em> since it ensures that the subscriptions
stay valid only a given execution context. In this way the handlers registered during
and operation are not invoked in the subsequent ones.</p>

<p>The <code>CartWriter</code> service seen above is simply the facade of our domain model. For
the sake of symmetry, There is also a facade for the read model, called <code>CartReader</code>.

  
    
  
  
    
  
  
  


<figure class="highlight cs">
  <figcaption>
    
      <span>CartReader.cs</span>
    
  </figcaption>
  <table>
    <tbody>
      <tr>
        <td class="gutter">
          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre>
        </td>
        <td class="code">
          <pre class="cs code-highlight">public class CartReader : ICartReader
{
  private readonly IReadOnlyRepository&lt;Cart&gt; cartRepository;
  private readonly IReadOnlyRepository&lt;CartItem&gt; cartItemRepository;

  public CartReader(IReadOnlyRepository&lt;Cart&gt; cartRepository,
      IReadOnlyRepository&lt;CartItem&gt; cartItemRepository)
  {
    this.cartRepository = cartRepository;
    this.cartItemRepository = cartItemRepository;
  }

  public async Task&lt;IEnumerable&lt;Cart&gt;&gt; FindAllAsync(
      Expression&lt;Func&lt;Cart, bool&gt;&gt; predicate)
  {
    return await cartRepository.FindAllAsync(predicate);
  }

  public async Task&lt;Cart&gt; GetByIdAsync(string id)
  {
    return await cartRepository.GetByIdAsync(id);
  }

  public async Task&lt;IEnumerable&lt;CartItem&gt;&gt; GetItemsOfAsync(string cartId)
  {
    return await cartItemRepository.FindAllAsync(x =&gt; x.CartId == cartId);
  }
}</pre>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
This class uses the repositories of the read model in order to returns data to the
client code.</p>

<p>Summing up, in order to implement the CQRS pattern, and show data to the users, I
created a read model (<code>Cart</code> and <code>CartItem</code>) which is synchronized with the domain
model through <code>CartUpdater</code> and I provided to application services (<code>CartWriter</code>
and <code>CartReader</code>) which cleanly separate writing operations from reading operations.</p>

<p>The power of this approach is that you can create as many read model as you need,
based on the features to be developed. Moreover, if an existing read model comes
out to be wrong or inadequate, e.g. due to changed requirements, you can delete and
create a new one. The latter can be populated by replaying all the domain events
available into the event store.</p>

<h2 id="conclusions">Conclusions</h2>

<p>The post is definitely the longest I&rsquo;ve written so far, however the subject deserved
all the effort and time I dedicated, and much more. The code I produced during the
experiment is more than what I could present, and it is available on <a href="https://github.com/VenomAV/EventSourcingCQRS">GitHub</a>.</p>

<p>Event Sourcing is a different paradigm from what normally a developer is used to,
and requires to change approach. Once done, it is simple to use. There are aspects
that deserve further investigation but those were not in scope: snapshots management,
publication of events to other applications, and correction of errors just to name
the most important.</p>

<p>CQRS becomes essential if you want to use Event Sourcing, but it can also be used
alone. To use its full potential, it is necessary to correctly manage possible delays
in updating the read model. For this reason, its adoption must be evaluated case-by-case,
however it is very flexible and the potentials I have experienced are certainly interesting.</p>

              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://andreavallotti.tech/en/tags/ddd/">ddd</a>

  <a class="tag tag--primary tag--small" href="https://andreavallotti.tech/en/tags/cqrs/">cqrs</a>

  <a class="tag tag--primary tag--small" href="https://andreavallotti.tech/en/tags/event-sourcing/">event sourcing</a>

  <a class="tag tag--primary tag--small" href="https://andreavallotti.tech/en/tags/architecture/">architecture</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  <nav>
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://andreavallotti.tech/en/2018/01/coderetreat-florence/" data-tooltip="Coderetreat Florence">
          
            <i class="fa fa-angle-left"></i>
            <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
          </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://andreavallotti.tech/en/2017/11/strategic-domain-driven-design/" data-tooltip="Strategic Domain-Driven Design">
          
            <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
            <i class="fa fa-angle-right"></i>
          </a>
        </li>
      
    </ul>
  </nav>
  <ul class="post-actions post-action-share">
    
      <li class="post-action hide-lg hide-md hide-sm">
        <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
          <i class="fa fa-share-alt"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http%3a%2f%2fwww.andreavallotti.tech%2fen%2f2018%2f01%2fevent-sourcing-and-cqrs-in-c%2f">
          <i class="fa fa-google-plus"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2fwww.andreavallotti.tech%2fen%2f2018%2f01%2fevent-sourcing-and-cqrs-in-c%2f">
          <i class="fa fa-facebook-official"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http%3a%2f%2fwww.andreavallotti.tech%2fen%2f2018%2f01%2fevent-sourcing-and-cqrs-in-c%2f">
          <i class="fa fa-twitter"></i>
        </a>
      </li>
    
    
      <li class="post-action">
        <a class="post-action-btn btn btn--default" href="#disqus_thread">
          <i class="fa fa-comment-o"></i>
        </a>
      </li>
    
    <li class="post-action">
      
        <a class="post-action-btn btn btn--default" href="#">
      
        <i class="fa fa-list"></i>
      </a>
    </li>
  </ul>
</div>


            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2019 Andrea Vallotti. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        <div class="post-actions-wrap">
  <nav>
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://andreavallotti.tech/en/2018/01/coderetreat-florence/" data-tooltip="Coderetreat Florence">
          
            <i class="fa fa-angle-left"></i>
            <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
          </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://andreavallotti.tech/en/2017/11/strategic-domain-driven-design/" data-tooltip="Strategic Domain-Driven Design">
          
            <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
            <i class="fa fa-angle-right"></i>
          </a>
        </li>
      
    </ul>
  </nav>
  <ul class="post-actions post-action-share">
    
      <li class="post-action hide-lg hide-md hide-sm">
        <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
          <i class="fa fa-share-alt"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http%3a%2f%2fwww.andreavallotti.tech%2fen%2f2018%2f01%2fevent-sourcing-and-cqrs-in-c%2f">
          <i class="fa fa-google-plus"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2fwww.andreavallotti.tech%2fen%2f2018%2f01%2fevent-sourcing-and-cqrs-in-c%2f">
          <i class="fa fa-facebook-official"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http%3a%2f%2fwww.andreavallotti.tech%2fen%2f2018%2f01%2fevent-sourcing-and-cqrs-in-c%2f">
          <i class="fa fa-twitter"></i>
        </a>
      </li>
    
    
      <li class="post-action">
        <a class="post-action-btn btn btn--default" href="#disqus_thread">
          <i class="fa fa-comment-o"></i>
        </a>
      </li>
    
    <li class="post-action">
      
        <a class="post-action-btn btn btn--default" href="#">
      
        <i class="fa fa-list"></i>
      </a>
    </li>
  </ul>
</div>


      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <ul class="share-options">
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http%3a%2f%2fwww.andreavallotti.tech%2fen%2f2018%2f01%2fevent-sourcing-and-cqrs-in-c%2f">
        <i class="fa fa-google-plus"></i><span>Share on Google Plus</span>
      </a>
    </li>
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2fwww.andreavallotti.tech%2fen%2f2018%2f01%2fevent-sourcing-and-cqrs-in-c%2f">
        <i class="fa fa-facebook-official"></i><span>Share on Facebook</span>
      </a>
    </li>
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http%3a%2f%2fwww.andreavallotti.tech%2fen%2f2018%2f01%2fevent-sourcing-and-cqrs-in-c%2f">
        <i class="fa fa-twitter"></i><span>Share on Twitter</span>
      </a>
    </li>
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://www.gravatar.com/avatar/100b4dd001736bba121c252821f9c063?s=110" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">Andrea Vallotti</h4>
    
      <div id="about-card-bio">Software enthusiast: architect, developer, and technology scout. Agile addicted. MCSD - App Builder, MCSA - Cloud Platform, CSM, and CSPO. Enjoy in constantly growing while crafting <em>awesome software</em>, and helping others doing the same. <a href="https://andreavallotti.tech/en/page/about">More.</a></div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Software Adventurer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        Italy
      </div>
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="Search" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center">no post found</div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://andreavallotti.tech/en/2018/08/modeling-and-separation-of-concerns-in-functional-programming/">
                <h3 class="media-heading">Modeling and separation of concerns in functional programming</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Aug 8, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">After my first experiment with functional programming, I decided to further study it in depth. Therefore, last March I attended &ldquo;Lean and Functional Domain Modelling&rdquo; workshop, organized by Avanscoperta, and held by Marcello Duarte. The workshop gave me good hints about functional modeling and fueled my curiosity to learn Scala and experiment more this paradigm.
In order to tackle this challenge I studied and practiced a lot. After some months, and several discussions with Matteo Baglini, I have been able to put together the puzzle, and I wrote this post.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://andreavallotti.tech/en/2018/01/coderetreat-florence/">
                <h3 class="media-heading">Coderetreat Florence</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jan 1, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">&ldquo;What matters is the journey&rdquo; (cit. Stefano Leli). This is the essence of Coderetreat.
I discovered this format during Urbino&rsquo;s Italian Agile Day 2017. During that event, I enjoyed practicing Test Driven Development (TDD) with other participants, and learning from the facilitators Matteo Vaccari, Stefano Leli and Gabriele Tondi. I liked the format so much that I decided to propose it in Florence, where I live, in order to let developers of my community to enjoy it and have fun together.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://andreavallotti.tech/en/2018/01/event-sourcing-and-cqrs-in-c/">
                <h3 class="media-heading">Event Sourcing and CQRS in C#</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jan 1, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">As promised in my previous post, in this article I examine practical aspects related to DDD and, in particular to CQRS and Event Sourcing patterns.
The main goal of my experiment is to implement an aggregate according to the Event Sourcing paradigm, and to create a separate read model to feed the pages of a Web application.
Before presenting the example, I am going to briefly introduce the main architectural patterns that have been used since DDD launch.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://andreavallotti.tech/en/2017/11/strategic-domain-driven-design/">
                <h3 class="media-heading">Strategic Domain-Driven Design</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">I was inspired to such an extent by Evans&rsquo; Blue Book, that I got passionate about Domain-Driven Design. I was still in the United States when, four months in advance, I registered to the Strategic Domain-Driven Design workshop held by Alberto Brandolini (aka ziobrando) and organized by Avanscoperta. I definitely wanted to attend.
Then, taken from the day to day activities, I lost the sense of time, when mid-October, I received an email from Avanscoperta that reminded me of the upcoming course.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://andreavallotti.tech/en/2017/10/using-ef-cores-migration-with-docker-and-mysql/">
                <h3 class="media-heading">Using EF Core&#39;s migration with Docker and MySQL</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Oct 10, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">In this post I explain how to create a .NET Core 2.0 console application which reads, and writes, data from MySQL, and uses Entity Framework Core, and migrations, in order to persist data and manage the DB schema. Furthermore I will show how to use Docker to be able to develop the application independently by the chosen environment.
In order to highlight the needed steps, I split the post in this way:</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://andreavallotti.tech/en/2017/09/there-and-back-again/">
                <h3 class="media-heading">There and Back Again</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">For those who loves Tolkien, the title could seem uppish. After all, I traveled 7.600 km, much more than Bilbo and fellowship, I met people I could hardly understand, and I talked to a dragon&hellip; Ok, the latter is not true, but let me believe so 😃
Jokes aside, I spent the first six months of this year in Indianapolis, USA. In this period, I had the chance to appreciate how lively Indiana&rsquo;s tech community is.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://andreavallotti.tech/en/2017/08/console.writeline-hello-world/">
                <h3 class="media-heading">Console.WriteLine( &#34;Hello, World!&#34; );</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Aug 8, 2017
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Every single experiment I did as a programmer began in this way: show Hello, World! on the monitor. Therefore I decided to start this new experiment (writing a blog) in the same way.
Who knows me well can tell that I never did my best in humanities, therefore &ldquo;writing a blog&rdquo; is not exactly in my style. However, I strongly believe that sharing experiences is essential in my job for two main reasons:</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://andreavallotti.tech/en/post/">
                <h3 class="media-heading">Posts</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Aug 8, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero="no post found"
         data-message-one="1 post found"
         data-message-other="{n} posts found">
         8 posts found
      </p>
    </div>
  </div>
</div>
    
  
    
    <div id="cover" style="background-image:url('https://res.cloudinary.com/andreavallotti/image/upload/blog/images/cover-NGC4258-M106.jpg');"></div>
  


    
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.js"></script>
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>


<script src="https://andreavallotti.tech/js/script-wl33z0n6ocaypepiqrazthtivfrliqijej4rq8ek8gvrv1awftmgjuv8k4zc.min.js"></script>

<script>
$(document).ready(function() {
  hljs.registerLanguage("fsharp",function(e){var t={b:"<",e:">",c:[e.inherit(e.TM,{b:/'[a-zA-Z0-9_]+/})]};return{aliases:["fs"],k:"abstract and as assert base begin class default delegate do done downcast downto elif else end exception extern false finally for fun function global if in inherit inline interface internal lazy let match member module mutable namespace new null of open or override private public rec return select sig static struct then to true try type upcast use val void when where while with yield",i:/\/\*/,c:[{cN:"keyword",b:/\b(yield|return|let|do)!/},{cN:"string",b:'@"',e:'"',c:[{b:'""'}]},{cN:"string",b:'"""',e:'"""'},e.C("\\(\\*","\\*\\)"),{cN:"class",bK:"type",e:"\\(|=|$",eE:!0,c:[e.UTM,t]},{cN:"meta",b:"\\[<",e:">\\]",r:10},{cN:"symbol",b:"\\B('[A-Za-z])\\b",c:[e.BE]},e.CLCM,e.inherit(e.QSM,{i:null}),e.CNM]}});
  hljs.registerLanguage("yaml", function(e) { var b = "true false yes no null", a = "^[ \\-]*", r = "[a-zA-Z_][\\w\\-]*", t = { cN: "attr", v: [{ b: a + r + ":" }, { b: a + '"' + r + '":' }, { b: a + "'" + r + "':" }] }, c = { cN: "template-variable", v: [{ b: ", e: " }, { b: "%{", e: "}" }] }, l = { cN: "string", r: 0, v: [{ b: /'/, e: /'/ }, { b: /"/, e: /"/ }, { b: /\S+/ }], c: [e.BE, c] }; return { cI: !0, aliases: ["yml", "YAML", "yaml"], c: [t, { cN: "meta", b: "^---s*$", r: 10 }, { cN: "string", b: "[\\|>] *$", rE: !0, c: l.c, e: t.v[0].b }, { b: "<%[%=-]?", e: "[%-]?%>", sL: "ruby", eB: !0, eE: !0, r: 0 }, { cN: "type", b: "!!" + e.UIR }, { cN: "meta", b: "&" + e.UIR + "$" }, { cN: "meta", b: "\\*" + e.UIR + "$" }, { cN: "bullet", b: "^ *-", r: 0 }, e.HCM, { bK: b, k: { literal: b } }, e.CNM, l] } });
  hljs.registerLanguage("dockerfile", function(e) { return { aliases: ["docker"], cI: !0, k: "from maintainer expose env arg user onbuild stopsignal", c: [e.HCM, e.ASM, e.QSM, e.NM, { bK: "run cmd entrypoint volume add copy workdir label healthcheck shell", starts: { e: /[^\\]\n/, sL: "bash" } }], i: "</" } });
  hljs.registerLanguage("scala",function(e){var t={cN:"meta",b:"@[A-Za-z]+"},a={cN:"subst",v:[{b:"\\$[A-Za-z0-9_]+"},{b:"\\${",e:"}"}]},r={cN:"string",v:[{b:'"',e:'"',i:"\\n",c:[e.BE]},{b:'"""',e:'"""',r:10},{b:'[a-z]+"',e:'"',i:"\\n",c:[e.BE,a]},{cN:"string",b:'[a-z]+"""',e:'"""',c:[a],r:10}]},c={cN:"symbol",b:"'\\w[\\w\\d_]*(?!')"},i={cN:"type",b:"\\b[A-Z][A-Za-z0-9_]*",r:0},s={cN:"title",b:/[^0-9\n\t "'(),.`{}\[\]:;][^\n\t "'(),.`{}\[\]:;]+|[^0-9\n\t "'(),.`{}\[\]:;=]/,r:0},n={cN:"class",bK:"class object trait type",e:/[:={\[\n;]/,eE:!0,c:[{bK:"extends with",r:10},{b:/\[/,e:/\]/,eB:!0,eE:!0,r:0,c:[i]},{cN:"params",b:/\(/,e:/\)/,eB:!0,eE:!0,r:0,c:[i]},s]},l={cN:"function",bK:"def",e:/[:={\[(\n;]/,eE:!0,c:[s]};return{k:{literal:"true false null",keyword:"type yield lazy override def with val var sealed abstract private trait object if forSome for while throw finally protected extends import final return else break new catch super class case package default try this match continue throws implicit"},c:[e.CLCM,e.CBCM,r,c,i,l,n,e.CNM,t]}});
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight').each(function(i, block) {
    var code = "";
    var languageFilter = (block.classList && block.classList.length > 1) ? [].slice.apply(block.classList) : null;
    var autoDetected = hljs.highlightAuto(block.innerText, languageFilter);

    autoDetected.value.split(/\r\n|\r|\n/).forEach(function(line) {
      code += "<span class=\"line\">" + line + "</span><br>";
    });
    if (code.length > 0) {
      block.innerHTML = code;  
    }
  });
  $('pre > code').each(function(i, block) {
    $(this).addClass('codeblock');
    hljs.highlightBlock(block);
  });
});
</script>

  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'http:\/\/www.andreavallotti.tech\/en\/2018\/01\/event-sourcing-and-cqrs-in-c\/';
          
            this.page.identifier = '\/en\/2018\/01\/event-sourcing-and-cqrs-in-c\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'andreavallotti';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  




<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#000"
    },
    "button": {
      "background": "#f1d600"
    }
  },
  "content": {
    "message": "This website uses cookies to ensure you get the best experience on our website.",
    "dismiss": "Got it!",
    "link": "Learn more",
    "href": "/en/page/cookie"
  }
})});
</script>
    
  </body>
</html>

